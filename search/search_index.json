{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Exploration Seismology EAS 4520/8803 Instructor Felix J. Herrmann Phone: +1 (404) 385-7069 Cherry Emerson, room 203 General Information Time and Location Monday/Wednesday 3:00 pm - 4:15 pm, ES&T L1114 Office Hours: Tuesday/Thursday 13:30 pm - 14:30 pm (or by appointment) Course Description This course contains a comprehensive review of reflection seismology and its application to oil and gas exploration. It includes key aspects of basic seismic data acquisition & processing and wave-equation based imaging and inversion. Required Textbook None required Recommended texts Sheriff, R. E., and L. P. Geldart (1995), Exploration Seismology (second edition), Cambridge University Express. Yilmaz, O. (2001), Seismic Data Analysis: Processing, Inversion, and Interpretation of Seismic Data, Society of Exploration Geophysicists. Yilmaz, O., SEG wiki page on Seismic Data Analysis Zhou, H. (2014), Practical Seismic Data Analysis, Cambridge University Press. Heiner Igel, Computational Seismology---A Practical Introduction Fichtner, Andreas, Full Seismic Waveform Modelling and Inversion Additional material will be made available under the tab Reading . Course Outline See Outline tab General introduction Seismic data acquisition From processing to inversion Compressive sensing Linearized inversion RTM & FWI Evaluation Homework assignments (35%) Midterm exam (25%) Course project (15%) Final exam (25%) Homework There will be homework exercises, which will mostly involve geophysics-related programs, computer simulations, and data analysis. These assignments is designed for each student to work by him/herself. This homework will count as 35% of your overall course grade. Project You are required to write a term paper on any topic related to geophysics. This can be a literature review of a selected topic, or research project involving calculations, data analysis, or theoretical results done in consultation with the instructor. The topic needed to be approved by the instructor before the midterm. Your paper should be written up in a journal form with length, figures and referencing in a format suitable for submission to journals like Geophysical Research Letters (GRL). Preliminary version of the final paper should be shown to the instructor for approval at least two weeks before the final due date. You will present your term paper in a 15 minute AGU-style talk; a 12 minute presentation with 3 minutes of questions. The project will count as 15% of your overall course grade. Grading for your project will be based on the 12% of the quality of the research and the written paper, and 3% of your presentation. Exams There will be a midterm (25%) and a final exam (25%). Both of them are closed book. Reference to texts or other documents such as previous semester course materials during exams is strictly forbidden. Using these materials will be considered a direct violation of academic policy and will be dealt with according to the GT Academic Honor Code. The use of electronic devices (e.g. cellular phones, computers etc.) other than non-programmable calculators during exams and quizzes is not allowed. Academic Honesty It is expected that all students are aware of their individual responsibilities under the Georgia Tech Academic Honor Code, which will be strictly adhered to in this class. The complete text of the Georgia Tech Academic Honor Code is at http://www.honor.gatech.edu/ .","title":"Exploration Seismology EAS 4520/8803"},{"location":"#exploration-seismology-eas-45208803","text":"","title":"Exploration Seismology EAS 4520/8803"},{"location":"#instructor","text":"Felix J. Herrmann Phone: +1 (404) 385-7069 Cherry Emerson, room 203","title":"Instructor"},{"location":"#general-information","text":"Time and Location Monday/Wednesday 3:00 pm - 4:15 pm, ES&T L1114 Office Hours: Tuesday/Thursday 13:30 pm - 14:30 pm (or by appointment)","title":"General Information"},{"location":"#course-description","text":"This course contains a comprehensive review of reflection seismology and its application to oil and gas exploration. It includes key aspects of basic seismic data acquisition & processing and wave-equation based imaging and inversion.","title":"Course Description"},{"location":"#required-textbook","text":"None required","title":"Required Textbook"},{"location":"#recommended-texts","text":"Sheriff, R. E., and L. P. Geldart (1995), Exploration Seismology (second edition), Cambridge University Express. Yilmaz, O. (2001), Seismic Data Analysis: Processing, Inversion, and Interpretation of Seismic Data, Society of Exploration Geophysicists. Yilmaz, O., SEG wiki page on Seismic Data Analysis Zhou, H. (2014), Practical Seismic Data Analysis, Cambridge University Press. Heiner Igel, Computational Seismology---A Practical Introduction Fichtner, Andreas, Full Seismic Waveform Modelling and Inversion Additional material will be made available under the tab Reading .","title":"Recommended texts"},{"location":"#course-outline","text":"See Outline tab General introduction Seismic data acquisition From processing to inversion Compressive sensing Linearized inversion RTM & FWI","title":"Course Outline"},{"location":"#evaluation","text":"Homework assignments (35%) Midterm exam (25%) Course project (15%) Final exam (25%)","title":"Evaluation"},{"location":"#homework","text":"There will be homework exercises, which will mostly involve geophysics-related programs, computer simulations, and data analysis. These assignments is designed for each student to work by him/herself. This homework will count as 35% of your overall course grade.","title":"Homework"},{"location":"#project","text":"You are required to write a term paper on any topic related to geophysics. This can be a literature review of a selected topic, or research project involving calculations, data analysis, or theoretical results done in consultation with the instructor. The topic needed to be approved by the instructor before the midterm. Your paper should be written up in a journal form with length, figures and referencing in a format suitable for submission to journals like Geophysical Research Letters (GRL). Preliminary version of the final paper should be shown to the instructor for approval at least two weeks before the final due date. You will present your term paper in a 15 minute AGU-style talk; a 12 minute presentation with 3 minutes of questions. The project will count as 15% of your overall course grade. Grading for your project will be based on the 12% of the quality of the research and the written paper, and 3% of your presentation.","title":"Project"},{"location":"#exams","text":"There will be a midterm (25%) and a final exam (25%). Both of them are closed book. Reference to texts or other documents such as previous semester course materials during exams is strictly forbidden. Using these materials will be considered a direct violation of academic policy and will be dealt with according to the GT Academic Honor Code. The use of electronic devices (e.g. cellular phones, computers etc.) other than non-programmable calculators during exams and quizzes is not allowed.","title":"Exams"},{"location":"#academic-honesty","text":"It is expected that all students are aware of their individual responsibilities under the Georgia Tech Academic Honor Code, which will be strictly adhered to in this class. The complete text of the Georgia Tech Academic Honor Code is at http://www.honor.gatech.edu/ .","title":"Academic Honesty"},{"location":"goals/","text":"General introduction Basic seismic data processing Give a description of a surface-seismic experiment Describe the basic steps of the post-stack seismic data flow and why they are important Explain why we need seismic exploration Name seismic transducers and setup for land and marine acquition Describe different seismic gathers What are the assumptions underlying NMO What is the role of the \u201cfold\u201d of the acquisition and why is it important Describe the mathematical relation between midpoint/offset and source-receiver coordinates Why is the sampling rate different for common-shot and common midpoint gathers Describe the principle of velocity estimation with NMO What does migration try to accomplish Give a geometric description of the process of zero-offset migration. Describe the different terms in the Rayleigh II integral Decribe the extrapolation \u201cwork flow\u201d Flowshart for shot extrapolation in the f-k domain What is the expression for the wavefield extrapolation operator in the f-k domain. What change do you need to make to do inverse extrapolation Describe in pictures forward wavefield extrapolation for a shot record with two events Describe recursive inverse wavefield extrapolation of a shot record with a single reflection event by a number of plots What is the main assumption on the behavior of the velocity in f-k based recursive extrapolation and what happens to the extrapolation operator compared to the lateral invariant case Name the five steps of prestack migration What are the underlying assumptions regarding the use of a particular migration scheme in relation to the complexity of the subsurface. Draw a schematic of the \u201cimpulse\u201d response of the migration operator and the linearized scattering operator. Describe the different steps of pre-stack shot migration What is the difference between pre- and post-stack migration? What is the effect of summing the images of the different shot gathers In what situation is pre-stack time migration a viable option and when not What migration scheme would you use in case of complex velocities and complex structure Wavefield extrapolation, pre-stack migration, and velocity analysis Wavefield extrapolation via Rayleigh II Wavefield extrapolation via the f-k domain $V(z)$ migration Shot record migration Recursive extrapolation in varying media Pre-stack shot migration One-way wave-equation migration Reverse-time migration Velocity-model estimation Traveltime tomography migration-velocity analysis What are the two prevailing methods to estimate the velocity model and what information do they need Describe the main principles of travel-time tomography Describe the main principles of migration velocity analyses What are the differences between these two methods of velocity model estimation Filtering Describe the principle and assumptions behind f-k filtering Write down the Radon transform in the physical and Fourier domain Describe Radon filtering sequence of operations to remove multiples Describe what the process of seismic deconvolution tries to accomplish Seismic data acquisition Give the Nyquist sampling critrion for the sampling of spatio-temporal wavefields Describe aliasing in 1-D and 2- D ( f-k domain). What is an airgun What is the ghost? What is the effect of the ghost on the amplitude spectrum? Describe azimuth and name at least three disadvantages of near azimuth acquisition. What does a rose diagram plot? Mention two different configurations to improve azimuthal coverage. Include sketches of the arrays and sources. Describe rich azimuth acquisition and include drawing. What is the main driver behind WAZ acquisition? Name at least four improvemens related to wide-azimuth acquisition? What is fold and why is it important? What are the main challenges in marine acquisition? What are the challenges of 3D acquisition? Name some recent developments. Describe coil sampling Give the main reasons why large offsets are required? From processing to inversion Describe what the forward and inverse models signify. What property do unitaty matrices have? What type of solution method should be used when the data synthetic data does not fit observed data exactly? Describe how one arrives at the least-squares solution m_{LS}=(A^TA)^{-1})A^Td ? In what situation, is the least-squares solution used? Is the matrix to be inverted tall, square, or fat? Describe the minmum norm solution and when is its use appropriate? Describe in words what the expression min_x|x|_2 subject to Ax=b expresses. Explain the difference between processing (applying the adjoint) and inversion How are convolution and correlation related related to linear operations Describe the 'dot test\u2019 and what does it accomplish Mention and describe at least three forward-adjoint pairs relevant to exploration seismology Write stacking, zero padding, and sampling as a matrix Proof that matrices that represent convolution and correlation are adjoints. What kind of matrix is the convolution in the Fourier domain. Sketch a column of the Parabolic Radon 'reverse\u2019 transform ( L^H ). Explain why it is important to 'invert the 'reverse\u2019 Radon transform\u2019 for multiple removal? What is the underlying assumption of minimizing the energy ( \\ell_2 -norm) on the model parameters? What does high-resolution try to accomplish and what is the underlying assumption on the model and the data? Compressive sensing How is sampling related to a linear system. When is the linear system underdetermined. How do the concepts of over- and underdetermined systems relate to sampling? Give the key ideas of Compressive Sensing. Give two examples of transforms that exploit the signal's structure by sparsity. Which interferences/artifacts are worse. Coherent aliases due to periodic sampling or incoherent noise due to randomized samping and why? Give at least two examples of randomized sampling and describe the impact on the sampling artifacts compared to conventional deterministic acquisition. Give an example of measurement (M) and sampling (R) matrices with low and hight coherence Which of the following acquisition scenarios creates favorable recovery conditions? Explain the role of sparsifying transforms and sparsity-promoting recovery. Describe what happens with the recovery SNR as (i) the subsampling ratio decreases, (ii) the sparsity-level increases, (iii) the noiselevel increases, and (iv) the decay rate of the sorted transform-domain coefficients increases. List a number of pitfalls/challenges related to applying compressive sensing to seismic acquisition in the field. Linearized inversion Describe three factors that influence the amplitudes of seismic waves Describe when the linearized refflection coefficients is a good approximation Give two different expressions for the linearized reflection coefficient in the acoustic case Mention \u201cnon-ray\u201d amplitude effects Describe linearized inversion. What are the two key factors expressing the relationship between the amplitudes of the reflection events and the acoustic medium properties. Introduce the corresponding matrices. What are the boundary conditions for the elastic wave equation at an interface? Describe the different reflection and transmission coefficients for the elastic case. Describe the linear convolutional model for the seismic reflection response. What are the underlying assupmtions of this model? What does the background velocity model describe and what properties should it have? List the different reflection and transmission coefficients for an interface between two elastic layers. What are these coefficients a function of and w.r.t. to which medium properties can these expressions be linearized? For non-zero and pre-critical angles, what are the orders in deltall 1 for these different reflection and transmission coefficients? Describe the \u201cwork flow\u201d of AVP inversion. Describe how the amplitudes of the plane-wave decomposition (via the linear Radon transform) are related to contrasts in the density, compressional, and shear wavespeeds. Describe the damped least-squares procedure to estimate the medium perturbations/contrasts. Is the system under or over determined? Why is damping needed? Describe issues with the spectral gap. RTM & FWI Describe in words what the adjoint state method corresponds to physically What is the geophysical interpretation of the gradient? Describe the equations for the computation of the gradient. What is their physical meaning? Draw the impulse response of a the linear Born scattering operator and its adjoint for a constant velocity model. What is the relationship between least-squares migration and Gauss-Newton? How is the action of the Jacobian evaluated? How many PDE solves does it take? List at least two difference between linearized inversion (least-squares migration and full-waveform inversion). Describe for what purpose full-waveform inversion is used in the context of migration and why. Describe a method to make imaging and inversion more efficient Describe a cross-well experiment Describe a surface-seismic experiment How does the sensitivity of these two methods compare? What sort of waves does full-waveform inversion rely on and why. List at least two requirements of full-waveform inversion on the acquisition. What does non-uniquness in full-waveform inversion refer to? List at least one strategy people use to avoid getting stuck in a local minimum? What does this imply w.r.t. the wavelength and the propagation distance.","title":"Goals"},{"location":"goals/#general-introduction","text":"","title":"General introduction"},{"location":"goals/#basic-seismic-data-processing","text":"Give a description of a surface-seismic experiment Describe the basic steps of the post-stack seismic data flow and why they are important Explain why we need seismic exploration Name seismic transducers and setup for land and marine acquition Describe different seismic gathers What are the assumptions underlying NMO What is the role of the \u201cfold\u201d of the acquisition and why is it important Describe the mathematical relation between midpoint/offset and source-receiver coordinates Why is the sampling rate different for common-shot and common midpoint gathers Describe the principle of velocity estimation with NMO What does migration try to accomplish Give a geometric description of the process of zero-offset migration. Describe the different terms in the Rayleigh II integral Decribe the extrapolation \u201cwork flow\u201d Flowshart for shot extrapolation in the f-k domain What is the expression for the wavefield extrapolation operator in the f-k domain. What change do you need to make to do inverse extrapolation Describe in pictures forward wavefield extrapolation for a shot record with two events Describe recursive inverse wavefield extrapolation of a shot record with a single reflection event by a number of plots What is the main assumption on the behavior of the velocity in f-k based recursive extrapolation and what happens to the extrapolation operator compared to the lateral invariant case Name the five steps of prestack migration What are the underlying assumptions regarding the use of a particular migration scheme in relation to the complexity of the subsurface. Draw a schematic of the \u201cimpulse\u201d response of the migration operator and the linearized scattering operator. Describe the different steps of pre-stack shot migration What is the difference between pre- and post-stack migration? What is the effect of summing the images of the different shot gathers In what situation is pre-stack time migration a viable option and when not What migration scheme would you use in case of complex velocities and complex structure","title":"Basic seismic data processing"},{"location":"goals/#wavefield-extrapolation-pre-stack-migration-and-velocity-analysis","text":"Wavefield extrapolation via Rayleigh II Wavefield extrapolation via the f-k domain $V(z)$ migration Shot record migration Recursive extrapolation in varying media Pre-stack shot migration One-way wave-equation migration Reverse-time migration Velocity-model estimation Traveltime tomography migration-velocity analysis What are the two prevailing methods to estimate the velocity model and what information do they need Describe the main principles of travel-time tomography Describe the main principles of migration velocity analyses What are the differences between these two methods of velocity model estimation","title":"Wavefield extrapolation, pre-stack migration, and velocity analysis"},{"location":"goals/#filtering","text":"Describe the principle and assumptions behind f-k filtering Write down the Radon transform in the physical and Fourier domain Describe Radon filtering sequence of operations to remove multiples Describe what the process of seismic deconvolution tries to accomplish","title":"Filtering"},{"location":"goals/#seismic-data-acquisition","text":"Give the Nyquist sampling critrion for the sampling of spatio-temporal wavefields Describe aliasing in 1-D and 2- D ( f-k domain). What is an airgun What is the ghost? What is the effect of the ghost on the amplitude spectrum? Describe azimuth and name at least three disadvantages of near azimuth acquisition. What does a rose diagram plot? Mention two different configurations to improve azimuthal coverage. Include sketches of the arrays and sources. Describe rich azimuth acquisition and include drawing. What is the main driver behind WAZ acquisition? Name at least four improvemens related to wide-azimuth acquisition? What is fold and why is it important? What are the main challenges in marine acquisition? What are the challenges of 3D acquisition? Name some recent developments. Describe coil sampling Give the main reasons why large offsets are required?","title":"Seismic data acquisition"},{"location":"goals/#from-processing-to-inversion","text":"Describe what the forward and inverse models signify. What property do unitaty matrices have? What type of solution method should be used when the data synthetic data does not fit observed data exactly? Describe how one arrives at the least-squares solution m_{LS}=(A^TA)^{-1})A^Td ? In what situation, is the least-squares solution used? Is the matrix to be inverted tall, square, or fat? Describe the minmum norm solution and when is its use appropriate? Describe in words what the expression min_x|x|_2 subject to Ax=b expresses. Explain the difference between processing (applying the adjoint) and inversion How are convolution and correlation related related to linear operations Describe the 'dot test\u2019 and what does it accomplish Mention and describe at least three forward-adjoint pairs relevant to exploration seismology Write stacking, zero padding, and sampling as a matrix Proof that matrices that represent convolution and correlation are adjoints. What kind of matrix is the convolution in the Fourier domain. Sketch a column of the Parabolic Radon 'reverse\u2019 transform ( L^H ). Explain why it is important to 'invert the 'reverse\u2019 Radon transform\u2019 for multiple removal? What is the underlying assumption of minimizing the energy ( \\ell_2 -norm) on the model parameters? What does high-resolution try to accomplish and what is the underlying assumption on the model and the data?","title":"From processing to inversion"},{"location":"goals/#compressive-sensing","text":"How is sampling related to a linear system. When is the linear system underdetermined. How do the concepts of over- and underdetermined systems relate to sampling? Give the key ideas of Compressive Sensing. Give two examples of transforms that exploit the signal's structure by sparsity. Which interferences/artifacts are worse. Coherent aliases due to periodic sampling or incoherent noise due to randomized samping and why? Give at least two examples of randomized sampling and describe the impact on the sampling artifacts compared to conventional deterministic acquisition. Give an example of measurement (M) and sampling (R) matrices with low and hight coherence Which of the following acquisition scenarios creates favorable recovery conditions? Explain the role of sparsifying transforms and sparsity-promoting recovery. Describe what happens with the recovery SNR as (i) the subsampling ratio decreases, (ii) the sparsity-level increases, (iii) the noiselevel increases, and (iv) the decay rate of the sorted transform-domain coefficients increases. List a number of pitfalls/challenges related to applying compressive sensing to seismic acquisition in the field.","title":"Compressive sensing"},{"location":"goals/#linearized-inversion","text":"Describe three factors that influence the amplitudes of seismic waves Describe when the linearized refflection coefficients is a good approximation Give two different expressions for the linearized reflection coefficient in the acoustic case Mention \u201cnon-ray\u201d amplitude effects Describe linearized inversion. What are the two key factors expressing the relationship between the amplitudes of the reflection events and the acoustic medium properties. Introduce the corresponding matrices. What are the boundary conditions for the elastic wave equation at an interface? Describe the different reflection and transmission coefficients for the elastic case. Describe the linear convolutional model for the seismic reflection response. What are the underlying assupmtions of this model? What does the background velocity model describe and what properties should it have? List the different reflection and transmission coefficients for an interface between two elastic layers. What are these coefficients a function of and w.r.t. to which medium properties can these expressions be linearized? For non-zero and pre-critical angles, what are the orders in deltall 1 for these different reflection and transmission coefficients? Describe the \u201cwork flow\u201d of AVP inversion. Describe how the amplitudes of the plane-wave decomposition (via the linear Radon transform) are related to contrasts in the density, compressional, and shear wavespeeds. Describe the damped least-squares procedure to estimate the medium perturbations/contrasts. Is the system under or over determined? Why is damping needed? Describe issues with the spectral gap.","title":"Linearized inversion"},{"location":"goals/#rtm-fwi","text":"Describe in words what the adjoint state method corresponds to physically What is the geophysical interpretation of the gradient? Describe the equations for the computation of the gradient. What is their physical meaning? Draw the impulse response of a the linear Born scattering operator and its adjoint for a constant velocity model. What is the relationship between least-squares migration and Gauss-Newton? How is the action of the Jacobian evaluated? How many PDE solves does it take? List at least two difference between linearized inversion (least-squares migration and full-waveform inversion). Describe for what purpose full-waveform inversion is used in the context of migration and why. Describe a method to make imaging and inversion more efficient Describe a cross-well experiment Describe a surface-seismic experiment How does the sensitivity of these two methods compare? What sort of waves does full-waveform inversion rely on and why. List at least two requirements of full-waveform inversion on the acquisition. What does non-uniquness in full-waveform inversion refer to? List at least one strategy people use to avoid getting stuck in a local minimum? What does this imply w.r.t. the wavelength and the propagation distance.","title":"RTM &amp; FWI"},{"location":"homework/","text":"Installation The assignments require Julia and Python to be installed. For Windows, I recommend to use docker as Devito does not support Windows. Julia To install julia follow https://julialang.org/downloads/ And install Julia 0.7 or earlier DO NOT INSTALL JULIA 1.0 Python The recommended installation is via conda to have a stable environment. https://conda.io/miniconda.html Packages For devito: git clone -b v3.2.0 https://github.com/opesci/devito.git cd devito conda env create -f environment.yml source activate devito pip install -e . This will create your devito environment. Remeber to always call source activate devito at every new session. For JUDI, start julia and run Pkg.add(\"JUDI\") all the dependencies should install. Docker First install docker for your system https://www.docker.com/products/docker-desktop Instead of having to install Python, Julia, Devito, JUDI and all the dependencies by yourself, you simply download the docker image and run it in a container. All you need to do is install docker and run: docker run -p 8888:8888 philippwitte/judi:v1.0.0 This will download the image and launch a jupyter notebook that you can access from your internet browser. The command will display a link, which looks something like this: Copy/paste this URL into your browser when you connect for the first time, to login with a token: http://0e27b13128d4:8888/?token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4&token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4 Copy-paste this link and replace the address 0e27b13128d4:8888 with localhost:8888 (the link is created inside the docker container, which doesn't know that you mapped this port to your localhost w/ port no. 8888). Instead of a notebook, you can also launch an interactive session with a terminal by running: docker run -it philippwitte/judi:v1.0.0 /bin/bash This will give you access to a terminal, in which you can start Julia/Python, run things interactively or modify code. Exercises During the course you will work on the following excercises A first look at seismic data. Intro to julia Exercise 1 NMO correction and velocity analysis Wavefield extrapolation and migration. Fourier, Radon and filtering. From processing to inversion I. From processing to inversion II. Introduction to Compressive Sensing Full Waveform inversion These exercises will introduce you to the Julia programming language , Devito -a Domain-specific Language (DSL) for automatic code generation for highly optimized finite differences, and Judi -a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size problems. Hand in Please turn in your assignments as pdf files. The assignments should be send to Felix J. Herrmann . Late hand ins are not accepted. Unless stated otherwise the labs are due one week after the lab. Feedback We will give you feedback on the marking of the exercises.","title":"Homework"},{"location":"homework/#installation","text":"The assignments require Julia and Python to be installed. For Windows, I recommend to use docker as Devito does not support Windows.","title":"Installation"},{"location":"homework/#julia","text":"To install julia follow https://julialang.org/downloads/ And install Julia 0.7 or earlier DO NOT INSTALL JULIA 1.0","title":"Julia"},{"location":"homework/#python","text":"The recommended installation is via conda to have a stable environment. https://conda.io/miniconda.html","title":"Python"},{"location":"homework/#packages","text":"For devito: git clone -b v3.2.0 https://github.com/opesci/devito.git cd devito conda env create -f environment.yml source activate devito pip install -e . This will create your devito environment. Remeber to always call source activate devito at every new session. For JUDI, start julia and run Pkg.add(\"JUDI\") all the dependencies should install.","title":"Packages"},{"location":"homework/#docker","text":"First install docker for your system https://www.docker.com/products/docker-desktop Instead of having to install Python, Julia, Devito, JUDI and all the dependencies by yourself, you simply download the docker image and run it in a container. All you need to do is install docker and run: docker run -p 8888:8888 philippwitte/judi:v1.0.0 This will download the image and launch a jupyter notebook that you can access from your internet browser. The command will display a link, which looks something like this: Copy/paste this URL into your browser when you connect for the first time, to login with a token: http://0e27b13128d4:8888/?token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4&token=84a95cf4319e8e68534f20c7c6474d9875f13c70270f35f4 Copy-paste this link and replace the address 0e27b13128d4:8888 with localhost:8888 (the link is created inside the docker container, which doesn't know that you mapped this port to your localhost w/ port no. 8888). Instead of a notebook, you can also launch an interactive session with a terminal by running: docker run -it philippwitte/judi:v1.0.0 /bin/bash This will give you access to a terminal, in which you can start Julia/Python, run things interactively or modify code.","title":"Docker"},{"location":"homework/#exercises","text":"During the course you will work on the following excercises A first look at seismic data. Intro to julia Exercise 1 NMO correction and velocity analysis Wavefield extrapolation and migration. Fourier, Radon and filtering. From processing to inversion I. From processing to inversion II. Introduction to Compressive Sensing Full Waveform inversion These exercises will introduce you to the Julia programming language , Devito -a Domain-specific Language (DSL) for automatic code generation for highly optimized finite differences, and Judi -a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size problems.","title":"Exercises"},{"location":"homework/#hand-in","text":"Please turn in your assignments as pdf files. The assignments should be send to Felix J. Herrmann . Late hand ins are not accepted. Unless stated otherwise the labs are due one week after the lab.","title":"Hand in"},{"location":"homework/#feedback","text":"We will give you feedback on the marking of the exercises.","title":"Feedback"},{"location":"info/","text":"EAS 4803/8803: Exploration Seismology Instructor Felix J. Herrmann Phone: +1 (404) 385-7069 Cherry Amerson, room 203 General Information Time and Location Monday/Wednesday 3:00 pm - 4:15 pm, ES&T to be announced Office Hours: Tuesday/Thursday 13:30 pm - 14:30 pm (or by appointment) Course Description This course contains a comprehensive review of reflection seismology and its application to oil and gas exploration industry. It includes key aspects of basic seismic data acquisition & processing and wave-equation based imaging and inversion. Required Textbook None required Recommended texts Sheriff, R. E., and L. P. Geldart (1995), Exploration Seismology (second edition), Cambridge University Express. Yilmaz, O. (2001), Seismic Data Analysis: Processing, Inversion, and Interpretation of Seismic Data, Society of Exploration Geophysicists. Yilmaz, O., SEG wiki page on Seismic Data Analysis Zhou, H. (2014), Practical Seismic Data Analysis, Cambridge University Press. Heiner Igel, Computational Seismology---A Practical Introduction Fichtner, Andreas, Full Seismic Waveform Modelling and Inversion Additional material will be made available on the course website . Course Outline See Outline tab General introduction Seismic data acquisition From processing to inversion Compressive sensing Linearized inversion RTM & FWI Evaluation Homework assignments (35%) Midterm exam (25%) Course project (15%) Final exam (25%) Homework There will be homework exercises, which will mostly involve geophysics-related programs, computer simulations, and data analysis. These assignments is designed for each student to work by him/herself. This homework will count as 35% of your overall course grade. Project You are required to write a term paper on any topic related to geophysics. This can be a literature review of a selected topic, or research project involving calculations, data analysis, or theoretical results done in consultation with the instructor. The topic needed to be approved by the instructor before the midterm. Your paper should be written up in a journal form with length, figures and referencing in a format suitable for submission to journals like Geophysical Research Letters (GRL). Preliminary version of the final paper should be shown to the instructor for approval at least two weeks before the final due date. You will present your term paper in a 15 minute AGU-style talk; a 12 minute presentation with 3 minutes of questions. The project will count as 15% of your overall course grade. Grading for your project will be based on the 12% of the quality of the research and the written paper, and 3% of your presentation. Exams There will be a midterm (25%) and a final exam (25%). Both of them are closed book. Reference to texts or other documents such as previous semester course materials during exams is strictly forbidden. Using these materials will be considered a direct violation of academic policy and will be dealt with according to the GT Academic Honor Code. The use of electronic devices (e.g. cellular phones, computers etc.) other than non-programmable calculators during exams and quizzes is not allowed. Academic Honesty It is expected that all students are aware of their individual responsibilities under the Georgia Tech Academic Honor Code, which will be strictly adhered to in this class. The complete text of the Georgia Tech Academic Honor Code is at http://www.honor.gatech.edu/ .","title":"Info"},{"location":"info/#eas-48038803-exploration-seismology","text":"","title":"EAS 4803/8803: Exploration Seismology"},{"location":"info/#instructor","text":"Felix J. Herrmann Phone: +1 (404) 385-7069 Cherry Amerson, room 203","title":"Instructor"},{"location":"info/#general-information","text":"Time and Location Monday/Wednesday 3:00 pm - 4:15 pm, ES&T to be announced Office Hours: Tuesday/Thursday 13:30 pm - 14:30 pm (or by appointment)","title":"General Information"},{"location":"info/#course-description","text":"This course contains a comprehensive review of reflection seismology and its application to oil and gas exploration industry. It includes key aspects of basic seismic data acquisition & processing and wave-equation based imaging and inversion.","title":"Course Description"},{"location":"info/#required-textbook","text":"None required","title":"Required Textbook"},{"location":"info/#recommended-texts","text":"Sheriff, R. E., and L. P. Geldart (1995), Exploration Seismology (second edition), Cambridge University Express. Yilmaz, O. (2001), Seismic Data Analysis: Processing, Inversion, and Interpretation of Seismic Data, Society of Exploration Geophysicists. Yilmaz, O., SEG wiki page on Seismic Data Analysis Zhou, H. (2014), Practical Seismic Data Analysis, Cambridge University Press. Heiner Igel, Computational Seismology---A Practical Introduction Fichtner, Andreas, Full Seismic Waveform Modelling and Inversion Additional material will be made available on the course website .","title":"Recommended texts"},{"location":"info/#course-outline","text":"See Outline tab General introduction Seismic data acquisition From processing to inversion Compressive sensing Linearized inversion RTM & FWI","title":"Course Outline"},{"location":"info/#evaluation","text":"Homework assignments (35%) Midterm exam (25%) Course project (15%) Final exam (25%)","title":"Evaluation"},{"location":"info/#homework","text":"There will be homework exercises, which will mostly involve geophysics-related programs, computer simulations, and data analysis. These assignments is designed for each student to work by him/herself. This homework will count as 35% of your overall course grade.","title":"Homework"},{"location":"info/#project","text":"You are required to write a term paper on any topic related to geophysics. This can be a literature review of a selected topic, or research project involving calculations, data analysis, or theoretical results done in consultation with the instructor. The topic needed to be approved by the instructor before the midterm. Your paper should be written up in a journal form with length, figures and referencing in a format suitable for submission to journals like Geophysical Research Letters (GRL). Preliminary version of the final paper should be shown to the instructor for approval at least two weeks before the final due date. You will present your term paper in a 15 minute AGU-style talk; a 12 minute presentation with 3 minutes of questions. The project will count as 15% of your overall course grade. Grading for your project will be based on the 12% of the quality of the research and the written paper, and 3% of your presentation.","title":"Project"},{"location":"info/#exams","text":"There will be a midterm (25%) and a final exam (25%). Both of them are closed book. Reference to texts or other documents such as previous semester course materials during exams is strictly forbidden. Using these materials will be considered a direct violation of academic policy and will be dealt with according to the GT Academic Honor Code. The use of electronic devices (e.g. cellular phones, computers etc.) other than non-programmable calculators during exams and quizzes is not allowed.","title":"Exams"},{"location":"info/#academic-honesty","text":"It is expected that all students are aware of their individual responsibilities under the Georgia Tech Academic Honor Code, which will be strictly adhered to in this class. The complete text of the Georgia Tech Academic Honor Code is at http://www.honor.gatech.edu/ .","title":"Academic Honesty"},{"location":"outline/","text":"General introduction Basic seismic data processing Explanation of the seismic method Seismic acquisition, different gathers, basics land and marine acquisition Post-stack seismic-data processing flow to create a seismic image: Common-midpoint sorting Normal-moveout correction Stack Zero-offset migration Time-to-depth conversion Time or depth migration Drawbacks of post-stack processing Intro pre-stack migration and velocity analysis Wavefield extrapolation, pre-stack migration, and velocity analysis Wavefield extrapolation via Rayleigh II Wavefield extrapolation via the f-k domain V(z) migration Shot record migration Recursive extrapolation in varying media Pre-stack shot migration One-way wave-equation migration Reverse-time migration Velocity-model estimation Traveltime tomography migration-velocity analysis Filtering f-k filtering Radon filtering Linear Radon Multiple-removal via parabolic Radon transform Parabolic versus hyperbolic Radon Deconvolution Seismic data acquisition Marine acquisition Challenges of 3D acquisition Wide-azimuth marine acquisition Coil sampling From processing to inversion Forward and inverse problems Over and underdermined problems Pseudo/generalized inverses Least-squares and damped least-squares inversion Convolution/correlation, Radon, and NMO in tems of linear operators (matrices) Forward and adjoint operations and the 'dot test\u2019 a la Jon Claerbout Pseudo inverse and regularization Deconvolution as an inversion problem ('matrix inverse\u2019) Forward operator for NMO and least-squares NMO Removing multiples by high-resolution Radon transform Compressive sensing Nyquist sampling and aliasing Exploiting structure is seismic data by transform-domain sparsity promotion Basics of Compressive Sensing Design principles of Compressive Sensing Application of Compressive Sensing to Exploration Seismology Jittered sampling of shots Simultaneous 'land\u2019 acquisition by summing randomly weighted shots Simultaneous 'marine\u2019 acquisition with time-dithered sources Linearized inversion Introduction linearized amplitude versus offset/angle inversion Linearization of the reflection and transmission coefficients w.r.t. contrasts in density, compressional, and shear wavespeeds. Convolutional model for seismic reflectivity Relation between amplitudes of seismic data in the Radon domain and the linearized reflection coefficient. Practical workflow for linearized inversion of amplitude-versus-offset data. RTM & FWI Basics of reverse-time migration (RTM) and full-waveform inversion (FWI) via the adjoint state method from physical and mathematical perspectives Derivation of expressions for the Jabobian and its adjoint Migration as the gradient of FWI Least-squares migration as the Gauss-Newton Hessian of FWI FWI with gradient descents FWI with Gauss-Newton Latest developments","title":"Outline"},{"location":"outline/#general-introduction","text":"","title":"General introduction"},{"location":"outline/#basic-seismic-data-processing","text":"Explanation of the seismic method Seismic acquisition, different gathers, basics land and marine acquisition Post-stack seismic-data processing flow to create a seismic image: Common-midpoint sorting Normal-moveout correction Stack Zero-offset migration Time-to-depth conversion Time or depth migration Drawbacks of post-stack processing Intro pre-stack migration and velocity analysis","title":"Basic seismic data processing"},{"location":"outline/#wavefield-extrapolation-pre-stack-migration-and-velocity-analysis","text":"Wavefield extrapolation via Rayleigh II Wavefield extrapolation via the f-k domain V(z) migration Shot record migration Recursive extrapolation in varying media Pre-stack shot migration One-way wave-equation migration Reverse-time migration Velocity-model estimation Traveltime tomography migration-velocity analysis","title":"Wavefield extrapolation, pre-stack migration, and velocity analysis"},{"location":"outline/#filtering","text":"f-k filtering Radon filtering Linear Radon Multiple-removal via parabolic Radon transform Parabolic versus hyperbolic Radon Deconvolution","title":"Filtering"},{"location":"outline/#seismic-data-acquisition","text":"Marine acquisition Challenges of 3D acquisition Wide-azimuth marine acquisition Coil sampling","title":"Seismic data acquisition"},{"location":"outline/#from-processing-to-inversion","text":"Forward and inverse problems Over and underdermined problems Pseudo/generalized inverses Least-squares and damped least-squares inversion Convolution/correlation, Radon, and NMO in tems of linear operators (matrices) Forward and adjoint operations and the 'dot test\u2019 a la Jon Claerbout Pseudo inverse and regularization Deconvolution as an inversion problem ('matrix inverse\u2019) Forward operator for NMO and least-squares NMO Removing multiples by high-resolution Radon transform","title":"From processing to inversion"},{"location":"outline/#compressive-sensing","text":"Nyquist sampling and aliasing Exploiting structure is seismic data by transform-domain sparsity promotion Basics of Compressive Sensing Design principles of Compressive Sensing Application of Compressive Sensing to Exploration Seismology Jittered sampling of shots Simultaneous 'land\u2019 acquisition by summing randomly weighted shots Simultaneous 'marine\u2019 acquisition with time-dithered sources","title":"Compressive sensing"},{"location":"outline/#linearized-inversion","text":"Introduction linearized amplitude versus offset/angle inversion Linearization of the reflection and transmission coefficients w.r.t. contrasts in density, compressional, and shear wavespeeds. Convolutional model for seismic reflectivity Relation between amplitudes of seismic data in the Radon domain and the linearized reflection coefficient. Practical workflow for linearized inversion of amplitude-versus-offset data.","title":"Linearized inversion"},{"location":"outline/#rtm-fwi","text":"Basics of reverse-time migration (RTM) and full-waveform inversion (FWI) via the adjoint state method from physical and mathematical perspectives Derivation of expressions for the Jabobian and its adjoint Migration as the gradient of FWI Least-squares migration as the Gauss-Newton Hessian of FWI FWI with gradient descents FWI with Gauss-Newton Latest developments","title":"RTM &amp; FWI"},{"location":"project/","text":"","title":"Project"},{"location":"reading/","text":"General introduction Reading material John Scales: Theory of Seismic Imaging Chapters 1, 2, 10.3 Guy Drijkoningen: Seismic Data Processing - TG001 / TA3600 Chapters 1,2,3, 4.6, 4.7. and Introduction to Reflection Seismology TA3520 Chapter 5. Yilmaz's \u201cbible\u201d Material presented in class Slides for Lecture 1: Introduction Slides for Lecture 2: Basic Seismic Data Processing I Slides for wavefield extrapolation, prestack migration, and velocity analysis Slides for f-k filtering, Radon filtering, and deconvolution Seismic data acquisition Material presented in class Practical aspects of seismic acquisition From processing to inversion Reading material Jon Claerbout: IMAGE ESTIMATION BY EXAMPLE: Geophysical Soundings Image Construction Chapter 1. John A. Scales, Martin L. Smith and Sven Treitel Introductory Geophysical Inverse Theory Chapter 4 Richard Baraniuk: More Is Less: Signal Processing and the Data Deluge Felix J. Herrmann, Michael P.Friedlander, Ozgur Yilmaz: Fighting the curse of dimensionality: compressive sensing in exploration seismology Felix J. Herrmann: Randomized sampling and sparsity: getting more information from fewer samples. Geophysics 75, WB173 (2010); doi:10.1190/1.350614 Material presented in class From Processing to Inversion Compressive sensing Reading material IEEE Signal Processing Magazine Richard Baraniuk: Compressive sensing and More Is Less: Signal Processing and the Data Deluge Emmanuel Candes and Michael Wakin: An introduction to Compressive Sensing Justin Romberg: Imaging via compressive sampling Felix J. Herrmann: Randomized sampling and sparsity: getting more information from fewer samples. Geophysics 75, WB173 (2010); doi:10.1190/1.350614 Felix J. Herrmann, Michael P. Friedlander, Ozgur Yilmaz: Fighting the curse of dimensionality: compressive sensing in exploration seismology Material presented in class Basics of Compressive sensing Linearized inversion Reading material A. Gisolf. On the shortcomings of linear AVP( AVO/AVA) inversion. Material presented in class Linearized inversion of amplitude-versus-offset data RTM & FWI Reading material Gerhard Pratt: Gauss-Newton and full Newton methods in frequency domain seismic waveform inversion. Geophysical Journal International, 133, 341-362. Andreas Fichtner: Full Seismic Waveform Modelling and Inversion chapter 10 and 11 Material presented in class Full-waveform inversion","title":"Reading"},{"location":"reading/#general-introduction","text":"","title":"General introduction"},{"location":"reading/#reading-material","text":"John Scales: Theory of Seismic Imaging Chapters 1, 2, 10.3 Guy Drijkoningen: Seismic Data Processing - TG001 / TA3600 Chapters 1,2,3, 4.6, 4.7. and Introduction to Reflection Seismology TA3520 Chapter 5. Yilmaz's \u201cbible\u201d","title":"Reading material"},{"location":"reading/#material-presented-in-class","text":"Slides for Lecture 1: Introduction Slides for Lecture 2: Basic Seismic Data Processing I Slides for wavefield extrapolation, prestack migration, and velocity analysis Slides for f-k filtering, Radon filtering, and deconvolution","title":"Material presented in class"},{"location":"reading/#seismic-data-acquisition","text":"","title":"Seismic data acquisition"},{"location":"reading/#material-presented-in-class_1","text":"Practical aspects of seismic acquisition","title":"Material presented in class"},{"location":"reading/#from-processing-to-inversion","text":"","title":"From processing to inversion"},{"location":"reading/#reading-material_1","text":"Jon Claerbout: IMAGE ESTIMATION BY EXAMPLE: Geophysical Soundings Image Construction Chapter 1. John A. Scales, Martin L. Smith and Sven Treitel Introductory Geophysical Inverse Theory Chapter 4 Richard Baraniuk: More Is Less: Signal Processing and the Data Deluge Felix J. Herrmann, Michael P.Friedlander, Ozgur Yilmaz: Fighting the curse of dimensionality: compressive sensing in exploration seismology Felix J. Herrmann: Randomized sampling and sparsity: getting more information from fewer samples. Geophysics 75, WB173 (2010); doi:10.1190/1.350614","title":"Reading material"},{"location":"reading/#material-presented-in-class_2","text":"From Processing to Inversion","title":"Material presented in class"},{"location":"reading/#compressive-sensing","text":"","title":"Compressive sensing"},{"location":"reading/#reading-material_2","text":"IEEE Signal Processing Magazine Richard Baraniuk: Compressive sensing and More Is Less: Signal Processing and the Data Deluge Emmanuel Candes and Michael Wakin: An introduction to Compressive Sensing Justin Romberg: Imaging via compressive sampling Felix J. Herrmann: Randomized sampling and sparsity: getting more information from fewer samples. Geophysics 75, WB173 (2010); doi:10.1190/1.350614 Felix J. Herrmann, Michael P. Friedlander, Ozgur Yilmaz: Fighting the curse of dimensionality: compressive sensing in exploration seismology","title":"Reading material"},{"location":"reading/#material-presented-in-class_3","text":"Basics of Compressive sensing","title":"Material presented in class"},{"location":"reading/#linearized-inversion","text":"","title":"Linearized inversion"},{"location":"reading/#reading-material_3","text":"A. Gisolf. On the shortcomings of linear AVP( AVO/AVA) inversion.","title":"Reading material"},{"location":"reading/#material-presented-in-class_4","text":"Linearized inversion of amplitude-versus-offset data","title":"Material presented in class"},{"location":"reading/#rtm-fwi","text":"","title":"RTM &amp; FWI"},{"location":"reading/#reading-material_4","text":"Gerhard Pratt: Gauss-Newton and full Newton methods in frequency domain seismic waveform inversion. Geophysical Journal International, 133, 341-362. Andreas Fichtner: Full Seismic Waveform Modelling and Inversion chapter 10 and 11","title":"Reading material"},{"location":"reading/#material-presented-in-class_5","text":"Full-waveform inversion","title":"Material presented in class"},{"location":"Assignments/Exercise1/","text":"Exercise 1: a first look at seismic data In this exercise we will load some data into Julia and perform some basic operations. Seismic data are typically stored in a special binary format: SEGY. These file-formats store the data as mutliple time-series (traces) with the corresponding header information containing specific information about such as time sampling and source/receiver locations. The Julia utilities for reading SEGY data is SeisIO using SeisIO, PyPlot Scaning the dataset Thhe first step is to scan the dataset to extract header/metadat. This metadat contains the geometry and parameters of the survey such as the source/receiver locations and time sampling rate. The convention for the metadata is as follows: - The Source positions use the Source keyword such as SourceX - The receiver position use the Group keyword such as GroupX # scan the dataset dir = Pkg.dir(\"SeisIO\") data_dir = \"/src/data\" \"/src/data\" We ca nnow scans the dataset with the segy_scan functin. This function returns a SeisCOn object where each block is a shot record with its metadata. blocks = segy_scan(string(dir, data_dir), \"overthrust\", [\"GroupX\", \"GroupY\", \"ns\", \"dt\"]); Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_41_60.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_21_40.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_61_80.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_1_20.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_81_97.segy Now extract the time, source and receiver coordinates (in seconds and meters) for all the traces. The source and receiver vectors have a length equal to the number of traces, the time vector has a length equal to the number of rows in the data matrix. sx = [get_header(blocks[i], \"SourceX\") for i=1:length(blocks)]; rx = [get_header(blocks[i], \"GroupX\") for i=1:length(blocks)]; # Get the tme axis. In this case the time axis is the same for all traces so we only need to extract it from the first trace # dt needs to be corrected for the binary setup # All the times are in ms dt = get_header(blocks[1], \"dt\")[1]/1000 nt = get_header(blocks[1], \"ns\")[1] T = 0:dt:(nt-1)*dt 0.0:4.0:3000.0 Calculate the offset and midpoint for each trace. This gives you vectors m (midpoint) and h (offset) with length equal to the number of traces. h = (s - r)/2; m = (s + r)/2; h = (sx .- rx)./2; m = (sx .+ rx)./2; The fold of the data is the number of traces in each midpoint gather. This can be easily visualized by a histogram. As we have a set of blocks we need to inspect each block seperately to recover the nuique set of midpoint location and the total number fo traces for this midpoint all_m = hcat(m'...) fold = [sum(all_m .== unique(all_m)[i]) for i=1:length(unique(all_m))]; all_h = hcat(h'...); figure(); bar(unique(all_m),fold ,align=\"center\", width=100); xlabel(\"midpoint [m]\"); ylabel(\"fold\"); title(\"fold\"); Can you interpret this figure? Different gathers Extract a midpoint gather. For example, a midpoint gather at m = 2550 looks like this: Im = find(all_m .== 7500.) figure() imshow(Float32.(blocks[1:97].data[:, Im]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=.05) PyObject <matplotlib.image.AxesImage object at 0x7f947ac9a550> Extract an offset-gather. For example, a zero-offset section looks like: # We need to sort it in physical units as the dataset may not be Ih = find(all_h .== 0.) inds = sortperm(all_m[Ih]') figure() imshow(Float32.(blocks[1:97].data[:, Ih[inds]]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=.1) PyObject <matplotlib.image.AxesImage object at 0x7f947ab7f048> What other different gathers can you think of? Extract and plot an example of all the different gathers. What are characteristic properties of the different gathers? Do not forget to label the axis and choose a reasonable colorscale. Hint: use cmap=Greys and adjust the color-axis vmin/vmax","title":"Exercise 1: a first look at seismic data"},{"location":"Assignments/Exercise1/#exercise-1-a-first-look-at-seismic-data","text":"In this exercise we will load some data into Julia and perform some basic operations. Seismic data are typically stored in a special binary format: SEGY. These file-formats store the data as mutliple time-series (traces) with the corresponding header information containing specific information about such as time sampling and source/receiver locations. The Julia utilities for reading SEGY data is SeisIO using SeisIO, PyPlot","title":"Exercise 1: a first look at seismic data"},{"location":"Assignments/Exercise1/#scaning-the-dataset","text":"Thhe first step is to scan the dataset to extract header/metadat. This metadat contains the geometry and parameters of the survey such as the source/receiver locations and time sampling rate. The convention for the metadata is as follows: - The Source positions use the Source keyword such as SourceX - The receiver position use the Group keyword such as GroupX # scan the dataset dir = Pkg.dir(\"SeisIO\") data_dir = \"/src/data\" \"/src/data\" We ca nnow scans the dataset with the segy_scan functin. This function returns a SeisCOn object where each block is a shot record with its metadata. blocks = segy_scan(string(dir, data_dir), \"overthrust\", [\"GroupX\", \"GroupY\", \"ns\", \"dt\"]); Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_41_60.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_21_40.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_61_80.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_1_20.segy Scanning ... /nethome/mlouboutin3/.julia/v0.6/SeisIO/src/data/overthrust_2D_shot_81_97.segy Now extract the time, source and receiver coordinates (in seconds and meters) for all the traces. The source and receiver vectors have a length equal to the number of traces, the time vector has a length equal to the number of rows in the data matrix. sx = [get_header(blocks[i], \"SourceX\") for i=1:length(blocks)]; rx = [get_header(blocks[i], \"GroupX\") for i=1:length(blocks)]; # Get the tme axis. In this case the time axis is the same for all traces so we only need to extract it from the first trace # dt needs to be corrected for the binary setup # All the times are in ms dt = get_header(blocks[1], \"dt\")[1]/1000 nt = get_header(blocks[1], \"ns\")[1] T = 0:dt:(nt-1)*dt 0.0:4.0:3000.0 Calculate the offset and midpoint for each trace. This gives you vectors m (midpoint) and h (offset) with length equal to the number of traces. h = (s - r)/2; m = (s + r)/2; h = (sx .- rx)./2; m = (sx .+ rx)./2; The fold of the data is the number of traces in each midpoint gather. This can be easily visualized by a histogram. As we have a set of blocks we need to inspect each block seperately to recover the nuique set of midpoint location and the total number fo traces for this midpoint all_m = hcat(m'...) fold = [sum(all_m .== unique(all_m)[i]) for i=1:length(unique(all_m))]; all_h = hcat(h'...); figure(); bar(unique(all_m),fold ,align=\"center\", width=100); xlabel(\"midpoint [m]\"); ylabel(\"fold\"); title(\"fold\"); Can you interpret this figure? Different gathers Extract a midpoint gather. For example, a midpoint gather at m = 2550 looks like this: Im = find(all_m .== 7500.) figure() imshow(Float32.(blocks[1:97].data[:, Im]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=.05) PyObject <matplotlib.image.AxesImage object at 0x7f947ac9a550> Extract an offset-gather. For example, a zero-offset section looks like: # We need to sort it in physical units as the dataset may not be Ih = find(all_h .== 0.) inds = sortperm(all_m[Ih]') figure() imshow(Float32.(blocks[1:97].data[:, Ih[inds]]), vmin=-1, vmax=1, cmap=\"Greys\", aspect=.1) PyObject <matplotlib.image.AxesImage object at 0x7f947ab7f048> What other different gathers can you think of? Extract and plot an example of all the different gathers. What are characteristic properties of the different gathers? Do not forget to label the axis and choose a reasonable colorscale. Hint: use cmap=Greys and adjust the color-axis vmin/vmax","title":"Scaning the dataset"},{"location":"Assignments/introduction_to_julia/","text":"A quick introduction to the Julia language Getting started Start an interactive Julia session by running julia from the command line. You can quit the session with quit() . Generally, all functions in Julia are run using parenthesis, even if there are no input arguments. pwd() \"/home/philipp\" whos() Base Module Compat 19502 KB Module Core Module IJulia 19567 KB Module JSON 19384 KB Module Main Module MbedTLS 19412 KB Module Nullables 1120 bytes Module ZMQ 19357 KB Module You can define Julia scripts as regular text files that end with .jl and use your favourite text editor to code. Once you have your script, e.g.: hello-world.jl println(\"Hello world\") you can run the script with include(\"hello-world.jl\") . The Julia REPL REPL stands for Read/Evaluate/Print/Loop and refers to the interactive Julia session (it's just like a Matlab session). It's good for experimenting, but any serious coding should be done using scripts instead. 42 42 4 + 5 9 100 / 5; Unlike Matlab, you can access Julia's help functions by typing the question mark, followed by the function that you want the documention of: ? quit search: \u001b[1mq\u001b[22m\u001b[1mu\u001b[22m\u001b[1mi\u001b[22m\u001b[1mt\u001b[22m \u001b[1mQ\u001b[22m\u001b[1mu\u001b[22m\u001b[1mi\u001b[22mckSor\u001b[1mt\u001b[22m Partial\u001b[1mQ\u001b[22m\u001b[1mu\u001b[22m\u001b[1mi\u001b[22mckSor\u001b[1mt\u001b[22m \u001b[1mq\u001b[22m\u001b[1mu\u001b[22mant\u001b[1mi\u001b[22mle \u001b[1mq\u001b[22m\u001b[1mu\u001b[22mant\u001b[1mi\u001b[22mle! quit() Quit the program indicating that the processes completed successfully. This function calls exit(0) (see exit ). Similarly, you can enter the shell mode by typing ; , which gives you access to a full bash terminal. ; pwd /home/philipp In contrast to Matlab, Julia treats all operators as functions. This means you can add two numbers in either of the two ways: a = 4 + 5 9 a = +(4, 5) 9 The same applies for any other operations, such as subtraction, multiplications etc. Some math constants are defined in Julia by default, such as: print(pi) \u03c0 = 3.1415926535897... Julia was designed with the intend to write code that resembles mathematics as close as possible. For example, you can omit the multiplication operator when working with variables: x = 5 2x + 4 # which is the same as 2*x + 4 14 Just as Matlab, but different than Python, Julia comes with many built-in math functions that you would need for everyday use: sin(pi / 2) 1.0 log(100) 4.605170185988092 exp(4.3) 73.69979369959579 rand() 0.5282624241978122 Packages and Plotting Packages provide additional functionalities, that are not included in core Julia. Packages are written both by official Julia programmers, as well as anyone else who programs in Julia. Since native Julia does not include any plotting tools, we have to download a third-party package, such as PyPlot or Plots : Pkg.add(\"PyPlot\") \u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mInstalling JUDI v0.1.0 \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mBuilding Dierckx \u001b[39m make: Nothing to be done for `all'. \u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mBuilding Conda \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mBuilding PyCall \u001b[39m\u001b[1m\u001b[36mInfo: \u001b[39m\u001b[22m\u001b[36mPyCall is using /home/philipp/GATechBundle/Miniconda3/bin/python3 (Python 3.6.6) at /home/philipp/GATechBundle/Miniconda3/bin/python3, libpython = /home/philipp/GATechBundle/Miniconda3/lib/libpython3.6m \u001b[39m\u001b[1m\u001b[36mInfo: \u001b[39m\u001b[22m\u001b[36m/home/philipp/.julia/v0.6/PyCall/deps/deps.jl has been updated \u001b[39m\u001b[1m\u001b[36mInfo: \u001b[39m\u001b[22m\u001b[36m/home/philipp/.julia/v0.6/PyCall/deps/PYTHON has been updated \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mPackage database updated \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mMETADATA is out-of-date \u2014 you may not have the latest version of PyPlot \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mUse `Pkg.update()` to get the latest versions of your packages \u001b[39m Once you have downloaded a package, you can use it by typing: using PyPlot This plotting package is based off Python's Matplotlib package and therefore shares much of the Syntax. Some common plotting commands include: x = 1:100; f = x .^ 2; plot(x, f) 1-element Array{PyCall.PyObject,1}: PyObject <matplotlib.lines.Line2D object at 0x7f4b10781d30> A = randn(20,30); imshow(A, extent=[0,30,20,40]) PyObject <matplotlib.image.AxesImage object at 0x7f4b105585c0> Arrays and tuples Arrays are defined in a similar fashion to Matlab: x = [1, 2, 3, 4, 5] 5-element Array{Int64,1}: 1 2 3 4 5 As you can see from the output on the screen, Julia actually cares about types of variables and arrays. Since we defined our array as a collection of integers, the type of our array is `{Int64,1} y = [1., 2., 3., 4., 5.] 5-element Array{Float64,1}: 1.0 2.0 3.0 4.0 5.0 You can make a vector out of anything, not just numbers. For example, you can collect strings in a vector like this: s = [\"This\", \"is\", \"a\", \"string\", \"vector\"] 5-element Array{String,1}: \"This\" \"is\" \"a\" \"string\" \"vector\" s = [\"string\", 4.0, sin, pi] 4-element Array{Any,1}: \"string\" 4.0 sin \u03c0 = 3.1415926535897... Multi-dimensional arrays are formed as follows: A = [1 2 3 4; 5 6 7 8] 2\u00d74 Array{Int64,2}: 1 2 3 4 5 6 7 8 Note that entries of the same row are separated by spaces and rows are separated by ; You can also initialize vectors/matrices of a given dimension in various ways: B = zeros(4,5) 4\u00d75 Array{Float64,2}: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 C = rand(2,3) 2\u00d73 Array{Float64,2}: 0.189405 0.938612 0.359612 0.553322 0.868266 0.102811 D = ones(4,2) 4\u00d72 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 Unlike Matlab, entries of matrices are accessed with square brackets, rather than parenthesis. Index counting starts at 1 (not 0). C[1,1] 0.1894051459813404 C[1,:] 3-element Array{Float64,1}: 0.189405 0.938612 0.359612 C[1,2:end] 2-element Array{Float64,1}: 0.938612 0.359612 Another useful structure, e.g. for plotting and loops, are range and linspace : r = 1:2:10 print(typeof(r)) StepRange{Int64,Int64} l = linspace(4,8.5, 7) print(typeof(l)) StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}} You can convert the vectors r and l to regular Julia arrays using the collect function: collect(r) 5-element Array{Int64,1}: 1 3 5 7 9 collect(l) 7-element Array{Float64,1}: 4.0 4.75 5.5 6.25 7.0 7.75 8.5 Similar to Matlab, it is possible to reshape arrays or stack multiple arrays to form new matrices: A = randn(3,4) 3\u00d74 Array{Float64,2}: 0.509555 -1.79653 0.842718 -0.713901 -0.0580305 0.609266 1.72787 -0.731359 0.10706 2.91134 -1.26744 -0.0453605 reshape(A, 4, 3) 4\u00d73 Array{Float64,2}: 0.509555 0.609266 -1.26744 -0.0580305 2.91134 -0.713901 0.10706 0.842718 -0.731359 -1.79653 1.72787 -0.0453605 vec(A) 12-element Array{Float64,1}: 0.509555 -0.0580305 0.10706 -1.79653 0.609266 2.91134 0.842718 1.72787 -1.26744 -0.713901 -0.731359 -0.0453605 B = [A; A] 6\u00d74 Array{Float64,2}: 0.509555 -1.79653 0.842718 -0.713901 -0.0580305 0.609266 1.72787 -0.731359 0.10706 2.91134 -1.26744 -0.0453605 0.509555 -1.79653 0.842718 -0.713901 -0.0580305 0.609266 1.72787 -0.731359 0.10706 2.91134 -1.26744 -0.0453605 One of the pitfalls of Julia is that assigning an array with the equal sign, does not copy the array, but creates a referece. A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = A 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] = 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] show(B) [2.0 2.0 2.0; 1.0 1.0 1.0] To copy an array, use the copy function A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = copy(A) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] = 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] println(B) [1.0 1.0 1.0; 1.0 1.0 1.0] We see that B has not been changed! Some other differences between Matlab and Julia are min and max functions. These functions only return the min/max of two input variables: min(5,100) 5 To obtain the smallest/largest entry of a vector, use the minimum and maximum functions: x = [1,2,3,4,5,6] println(minimum(x)) println(maximum(x)) 1 6 Controll Flow Control flow in Julia, i.e. if/else statements, for loops or while loops, are similar to other programming languages. Here are some examples of different ways of controlling the flow: for j=1:2:8 println(j) end 1 3 5 7 for color in [\"red\", \"green\", \"blue\"] # an array print(color, \" \") end red green blue x = 10 while x > 1 x -= 1 println(x) end 9 8 7 6 5 4 3 2 1 name = \"Julia\" if name == \"Julia\" println(\"I like Julia\") elseif name == \"Python\" println(\"I like Python.\") println(\"But I prefer Julia.\") else println(\"I don't know what I like\") end I like Julia Functions Functions are a useful building block to structure your code and build subroutines etc. The most generic way to define functions in Julia is like this: function my_function(arg1, arg2) # do some work end my_function (generic function with 1 method) Functions can have any number of input arguments, including none: function breakfast() maketoast() brewcoffee() end breakfast (generic function with 1 method) By default, Julia functions always return the output from the last line of function. By using the return keyword, you can indicate a specific value that should be returned. function my_func(x, y) x_new = 2x y_new = 2y end z = my_func(3,4) 8 function my_func(x, y) return x_new = 2x y_new = 2y end z = my_func(3,4) 6 By grouping results as tuples, it is possible to return multiple variables: function my_func(x, y) x_new = 2x y_new = 2y return (x_new, y_new) end z = my_func(3,4) (6, 8)","title":"Introduction to julia"},{"location":"Assignments/introduction_to_julia/#a-quick-introduction-to-the-julia-language","text":"","title":"A quick introduction to the Julia language"},{"location":"Assignments/introduction_to_julia/#getting-started","text":"Start an interactive Julia session by running julia from the command line. You can quit the session with quit() . Generally, all functions in Julia are run using parenthesis, even if there are no input arguments. pwd() \"/home/philipp\" whos() Base Module Compat 19502 KB Module Core Module IJulia 19567 KB Module JSON 19384 KB Module Main Module MbedTLS 19412 KB Module Nullables 1120 bytes Module ZMQ 19357 KB Module You can define Julia scripts as regular text files that end with .jl and use your favourite text editor to code. Once you have your script, e.g.: hello-world.jl println(\"Hello world\") you can run the script with include(\"hello-world.jl\") .","title":"Getting started"},{"location":"Assignments/introduction_to_julia/#the-julia-repl","text":"REPL stands for Read/Evaluate/Print/Loop and refers to the interactive Julia session (it's just like a Matlab session). It's good for experimenting, but any serious coding should be done using scripts instead. 42 42 4 + 5 9 100 / 5; Unlike Matlab, you can access Julia's help functions by typing the question mark, followed by the function that you want the documention of: ? quit search: \u001b[1mq\u001b[22m\u001b[1mu\u001b[22m\u001b[1mi\u001b[22m\u001b[1mt\u001b[22m \u001b[1mQ\u001b[22m\u001b[1mu\u001b[22m\u001b[1mi\u001b[22mckSor\u001b[1mt\u001b[22m Partial\u001b[1mQ\u001b[22m\u001b[1mu\u001b[22m\u001b[1mi\u001b[22mckSor\u001b[1mt\u001b[22m \u001b[1mq\u001b[22m\u001b[1mu\u001b[22mant\u001b[1mi\u001b[22mle \u001b[1mq\u001b[22m\u001b[1mu\u001b[22mant\u001b[1mi\u001b[22mle! quit() Quit the program indicating that the processes completed successfully. This function calls exit(0) (see exit ). Similarly, you can enter the shell mode by typing ; , which gives you access to a full bash terminal. ; pwd /home/philipp In contrast to Matlab, Julia treats all operators as functions. This means you can add two numbers in either of the two ways: a = 4 + 5 9 a = +(4, 5) 9 The same applies for any other operations, such as subtraction, multiplications etc. Some math constants are defined in Julia by default, such as: print(pi) \u03c0 = 3.1415926535897... Julia was designed with the intend to write code that resembles mathematics as close as possible. For example, you can omit the multiplication operator when working with variables: x = 5 2x + 4 # which is the same as 2*x + 4 14 Just as Matlab, but different than Python, Julia comes with many built-in math functions that you would need for everyday use: sin(pi / 2) 1.0 log(100) 4.605170185988092 exp(4.3) 73.69979369959579 rand() 0.5282624241978122","title":"The Julia REPL"},{"location":"Assignments/introduction_to_julia/#packages-and-plotting","text":"Packages provide additional functionalities, that are not included in core Julia. Packages are written both by official Julia programmers, as well as anyone else who programs in Julia. Since native Julia does not include any plotting tools, we have to download a third-party package, such as PyPlot or Plots : Pkg.add(\"PyPlot\") \u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mInstalling JUDI v0.1.0 \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mBuilding Dierckx \u001b[39m make: Nothing to be done for `all'. \u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mBuilding Conda \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mBuilding PyCall \u001b[39m\u001b[1m\u001b[36mInfo: \u001b[39m\u001b[22m\u001b[36mPyCall is using /home/philipp/GATechBundle/Miniconda3/bin/python3 (Python 3.6.6) at /home/philipp/GATechBundle/Miniconda3/bin/python3, libpython = /home/philipp/GATechBundle/Miniconda3/lib/libpython3.6m \u001b[39m\u001b[1m\u001b[36mInfo: \u001b[39m\u001b[22m\u001b[36m/home/philipp/.julia/v0.6/PyCall/deps/deps.jl has been updated \u001b[39m\u001b[1m\u001b[36mInfo: \u001b[39m\u001b[22m\u001b[36m/home/philipp/.julia/v0.6/PyCall/deps/PYTHON has been updated \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mPackage database updated \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mMETADATA is out-of-date \u2014 you may not have the latest version of PyPlot \u001b[39m\u001b[1m\u001b[36mINFO: \u001b[39m\u001b[22m\u001b[36mUse `Pkg.update()` to get the latest versions of your packages \u001b[39m Once you have downloaded a package, you can use it by typing: using PyPlot This plotting package is based off Python's Matplotlib package and therefore shares much of the Syntax. Some common plotting commands include: x = 1:100; f = x .^ 2; plot(x, f) 1-element Array{PyCall.PyObject,1}: PyObject <matplotlib.lines.Line2D object at 0x7f4b10781d30> A = randn(20,30); imshow(A, extent=[0,30,20,40]) PyObject <matplotlib.image.AxesImage object at 0x7f4b105585c0>","title":"Packages and Plotting"},{"location":"Assignments/introduction_to_julia/#arrays-and-tuples","text":"Arrays are defined in a similar fashion to Matlab: x = [1, 2, 3, 4, 5] 5-element Array{Int64,1}: 1 2 3 4 5 As you can see from the output on the screen, Julia actually cares about types of variables and arrays. Since we defined our array as a collection of integers, the type of our array is `{Int64,1} y = [1., 2., 3., 4., 5.] 5-element Array{Float64,1}: 1.0 2.0 3.0 4.0 5.0 You can make a vector out of anything, not just numbers. For example, you can collect strings in a vector like this: s = [\"This\", \"is\", \"a\", \"string\", \"vector\"] 5-element Array{String,1}: \"This\" \"is\" \"a\" \"string\" \"vector\" s = [\"string\", 4.0, sin, pi] 4-element Array{Any,1}: \"string\" 4.0 sin \u03c0 = 3.1415926535897... Multi-dimensional arrays are formed as follows: A = [1 2 3 4; 5 6 7 8] 2\u00d74 Array{Int64,2}: 1 2 3 4 5 6 7 8 Note that entries of the same row are separated by spaces and rows are separated by ; You can also initialize vectors/matrices of a given dimension in various ways: B = zeros(4,5) 4\u00d75 Array{Float64,2}: 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 C = rand(2,3) 2\u00d73 Array{Float64,2}: 0.189405 0.938612 0.359612 0.553322 0.868266 0.102811 D = ones(4,2) 4\u00d72 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 Unlike Matlab, entries of matrices are accessed with square brackets, rather than parenthesis. Index counting starts at 1 (not 0). C[1,1] 0.1894051459813404 C[1,:] 3-element Array{Float64,1}: 0.189405 0.938612 0.359612 C[1,2:end] 2-element Array{Float64,1}: 0.938612 0.359612 Another useful structure, e.g. for plotting and loops, are range and linspace : r = 1:2:10 print(typeof(r)) StepRange{Int64,Int64} l = linspace(4,8.5, 7) print(typeof(l)) StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}} You can convert the vectors r and l to regular Julia arrays using the collect function: collect(r) 5-element Array{Int64,1}: 1 3 5 7 9 collect(l) 7-element Array{Float64,1}: 4.0 4.75 5.5 6.25 7.0 7.75 8.5 Similar to Matlab, it is possible to reshape arrays or stack multiple arrays to form new matrices: A = randn(3,4) 3\u00d74 Array{Float64,2}: 0.509555 -1.79653 0.842718 -0.713901 -0.0580305 0.609266 1.72787 -0.731359 0.10706 2.91134 -1.26744 -0.0453605 reshape(A, 4, 3) 4\u00d73 Array{Float64,2}: 0.509555 0.609266 -1.26744 -0.0580305 2.91134 -0.713901 0.10706 0.842718 -0.731359 -1.79653 1.72787 -0.0453605 vec(A) 12-element Array{Float64,1}: 0.509555 -0.0580305 0.10706 -1.79653 0.609266 2.91134 0.842718 1.72787 -1.26744 -0.713901 -0.731359 -0.0453605 B = [A; A] 6\u00d74 Array{Float64,2}: 0.509555 -1.79653 0.842718 -0.713901 -0.0580305 0.609266 1.72787 -0.731359 0.10706 2.91134 -1.26744 -0.0453605 0.509555 -1.79653 0.842718 -0.713901 -0.0580305 0.609266 1.72787 -0.731359 0.10706 2.91134 -1.26744 -0.0453605 One of the pitfalls of Julia is that assigning an array with the equal sign, does not copy the array, but creates a referece. A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = A 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] = 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] show(B) [2.0 2.0 2.0; 1.0 1.0 1.0] To copy an array, use the copy function A = ones(2,3) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 B = copy(A) 2\u00d73 Array{Float64,2}: 1.0 1.0 1.0 1.0 1.0 1.0 A[1,:] = 2 println(A) [2.0 2.0 2.0; 1.0 1.0 1.0] println(B) [1.0 1.0 1.0; 1.0 1.0 1.0] We see that B has not been changed! Some other differences between Matlab and Julia are min and max functions. These functions only return the min/max of two input variables: min(5,100) 5 To obtain the smallest/largest entry of a vector, use the minimum and maximum functions: x = [1,2,3,4,5,6] println(minimum(x)) println(maximum(x)) 1 6","title":"Arrays and tuples"},{"location":"Assignments/introduction_to_julia/#controll-flow","text":"Control flow in Julia, i.e. if/else statements, for loops or while loops, are similar to other programming languages. Here are some examples of different ways of controlling the flow: for j=1:2:8 println(j) end 1 3 5 7 for color in [\"red\", \"green\", \"blue\"] # an array print(color, \" \") end red green blue x = 10 while x > 1 x -= 1 println(x) end 9 8 7 6 5 4 3 2 1 name = \"Julia\" if name == \"Julia\" println(\"I like Julia\") elseif name == \"Python\" println(\"I like Python.\") println(\"But I prefer Julia.\") else println(\"I don't know what I like\") end I like Julia","title":"Controll Flow"},{"location":"Assignments/introduction_to_julia/#functions","text":"Functions are a useful building block to structure your code and build subroutines etc. The most generic way to define functions in Julia is like this: function my_function(arg1, arg2) # do some work end my_function (generic function with 1 method) Functions can have any number of input arguments, including none: function breakfast() maketoast() brewcoffee() end breakfast (generic function with 1 method) By default, Julia functions always return the output from the last line of function. By using the return keyword, you can indicate a specific value that should be returned. function my_func(x, y) x_new = 2x y_new = 2y end z = my_func(3,4) 8 function my_func(x, y) return x_new = 2x y_new = 2y end z = my_func(3,4) 6 By grouping results as tuples, it is possible to return multiple variables: function my_func(x, y) x_new = 2x y_new = 2y return (x_new, y_new) end z = my_func(3,4) (6, 8)","title":"Functions"}]}